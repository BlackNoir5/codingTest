
<img src = "/img/BeakJoon/백준.png" width=1000px alt="백준_qorwns_Beakjoon"></img>
백준 1874번 문제 : https://www.acmicpc.net/problem/17298

<meta name="keywords" content="코딩테스트, 스택, 정렬, 오큰수">
<meta name=“description” content = “백준 17298번 문제”>

</br></br>

백준 17298문제 해설
=============
</br>

### 문제
크기가 N인 수열 A = A1, A2, ..., AN이 있다. 수열의 각 원소 Ai에 대해서 오큰수 NGE(i)를 구하려고 한다. Ai의 오큰수는 오른쪽에 있으면서 Ai보다 큰 수 중에서 가장 왼쪽에 있는 수를 의미한다. 그러한 수가 없는 경우에 오큰수는 -1이다.

예를 들어, A = [3, 5, 2, 7]인 경우 NGE(1) = 5, NGE(2) = 7, NGE(3) = 7, NGE(4) = -1이다. A = [9, 5, 4, 8]인 경우에는 NGE(1) = -1, NGE(2) = 8, NGE(3) = 8, NGE(4) = -1이다.

### 입력
첫째 줄에 수열 A의 크기 N (1 ≤ N ≤ 1,000,000)이 주어진다. 둘째 줄에 수열 A의 원소 A1, A2, ..., AN (1 ≤ Ai ≤ 1,000,000)이 주어진다.

### 출력
총 N개의 수 NGE(1), NGE(2), ..., NGE(N)을 공백으로 구분해 출력한다.
</br></br></br>
<img src = "/img/BeakJoon/No.17298.png" width=1000px alt="오큰수"></img>
</br></br>

## 문제의 이해

오큰수 문제의 이해 자체는 어렵지 않다. 그냥 현재 값보다 큰 오른쪽 수 중 가장 왼쪽에 있는것으로 현재 오른쪽 인덱스를 보면서 찾으면된다. 문제점은 최적화인데 어떻게 실행 속도를 절감할 수 있는지에 대한 포인트가
이 문제의 핵심이다.

분기점을 먼저 생각해본다.
1. 다음에 있는 인덱스의 숫자가 더 큰 경우
-> 바로 반환

2. 더 작은수가 반복되다가 더 큰수를 만난 경우
-> 작은수의 횟수 만큼 큰수를 찍어내기

3. 작은수만 나오다가 끝난 경우
-> -1 반환하기

위 분기점의 2번 조건 때문에 스택을 이용해서 값을 처리하는 방법이 좋아보인다.
스택으로 위 분기점에 따른 행동을 생각해보면

1. 스택에 현재값을 빼고 큰 수를 반환한 뒤 그 값을 넣는다.
2. 비어있지 않고 작은수가 나왔다면 스택에 계속 집어넣고 큰 수가 나왔다면 작은 동안 반환하다가 큰 수에서 멈추고 큰 수를 스택에 넣는다.
3. 빠지지 않고 남은 스택 값들을 -1로 반환한다.

3번 행동에서 -1을 반환할 위치를 특정하기 위해서 스택에 인덱스를 넣도록 한다.

---

### 예제 1번.

---

### 예제 2번.

---

### 알고리즘


```java
   
```
